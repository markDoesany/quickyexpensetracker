package services

import (
	"fmt"
	"os"
	"quickyexpensetracker/api"
	"quickyexpensetracker/models"
	"quickyexpensetracker/utils"
	"testing"
	"time"
	// "github.com/stretchr/testify/assert" // For assertions
	// Mocks would ideally be generated by a framework or hand-crafted interfaces
)

// --- Mocking Infrastructure (Conceptual) ---
// In a real scenario, you'd use interfaces and a mocking library (e.g., gomock).
// Since the functions in api and utils are package-level, true mocking without
// modifying source code to use interfaces is hard.
// Alternatives include:
// 1. Using a test-only build with swapped implementations (build tags).
// 2. Monkey patching (e.g., using `go-monkey`). Risky and not always recommended.
// 3. Refactoring original code to use interfaces (Dependency Injection).

// For this example, we'll use global variables to "mock" function calls.
// This is a simplified and somewhat fragile approach, not for production test suites
// without careful scoping and reset mechanisms.

var (
	mockGetPendingUnnotifiedReminders func() ([]models.RemindersLog, error)
	mockSendTextMessage               func(message, psid, token string) error
	mockMarkReminderAsNotified        func(reminderID string) error
	mockUpdateDueDateAndNotified      func(reminderID string, newDueDate time.Time, notified bool) error
	mockGetExpensesForPeriod          func(userID string, start time.Time, end time.Time) ([]models.ExpensesLog, float64, error)
	// utils.CalculateNextDueDate is simple enough we might use the real one, or mock it too.
	mockCalculateNextDueDate func(currentDueDate time.Time, frequency string) (time.Time, error)
	// utils.GenerateExpenseSummaryMessage is also simple, could use real or mock.
	mockGenerateExpenseSummaryMessage func(frequency string, expenses []models.ExpensesLog, totalAmount float64) string
)

// Original function references to restore after tests
var (
	originalGetPendingUnnotifiedReminders = api.GetPendingUnnotifiedReminders
	originalSendTextMessage               = utils.SendTextMessage
	originalMarkReminderAsNotified        = api.MarkReminderAsNotified
	originalUpdateDueDateAndNotified      = api.UpdateReminderDueDateAndNotifiedStatus
	originalGetExpensesForPeriod          = api.GetExpensesForPeriod
	originalCalculateNextDueDate          = utils.CalculateNextDueDate
	originalGenerateExpenseSummaryMessage = utils.GenerateExpenseSummaryMessage
)

func setupMocks() {
	api.GetPendingUnnotifiedReminders = func() ([]models.RemindersLog, error) {
		if mockGetPendingUnnotifiedReminders != nil {
			return mockGetPendingUnnotifiedReminders()
		}
		return nil, fmt.Errorf("mockGetPendingUnnotifiedReminders not implemented")
	}
	utils.SendTextMessage = func(message, psid, token string) error {
		if mockSendTextMessage != nil {
			return mockSendTextMessage(message, psid, token)
		}
		return fmt.Errorf("mockSendTextMessage not implemented")
	}
	api.MarkReminderAsNotified = func(reminderID string) error {
		if mockMarkReminderAsNotified != nil {
			return mockMarkReminderAsNotified(reminderID)
		}
		return fmt.Errorf("mockMarkReminderAsNotified not implemented")
	}
	api.UpdateReminderDueDateAndNotifiedStatus = func(reminderID string, newDueDate time.Time, notified bool) error {
		if mockUpdateDueDateAndNotified != nil {
			return mockUpdateDueDateAndNotified(reminderID, newDueDate, notified)
		}
		return fmt.Errorf("mockUpdateDueDateAndNotified not implemented")
	}
	api.GetExpensesForPeriod = func(userID string, start time.Time, end time.Time) ([]models.ExpensesLog, float64, error) {
		if mockGetExpensesForPeriod != nil {
			return mockGetExpensesForPeriod(userID, start, end)
		}
		return nil, 0, fmt.Errorf("mockGetExpensesForPeriod not implemented")
	}
	utils.CalculateNextDueDate = func(currentDueDate time.Time, frequency string) (time.Time, error) {
		if mockCalculateNextDueDate != nil {
			return mockCalculateNextDueDate(currentDueDate, frequency)
		}
		// Fallback to real implementation if specific mock not set, or error
		return originalCalculateNextDueDate(currentDueDate, frequency)
	}
	utils.GenerateExpenseSummaryMessage = func(frequency string, expenses []models.ExpensesLog, totalAmount float64) string {
		if mockGenerateExpenseSummaryMessage != nil {
			return mockGenerateExpenseSummaryMessage(frequency, expenses, totalAmount)
		}
		// Fallback to real implementation
		return originalGenerateExpenseSummaryMessage(frequency, expenses, totalAmount)
	}
}

func teardownMocks() {
	api.GetPendingUnnotifiedReminders = originalGetPendingUnnotifiedReminders
	utils.SendTextMessage = originalSendTextMessage
	api.MarkReminderAsNotified = originalMarkReminderAsNotified
	api.UpdateReminderDueDateAndNotifiedStatus = originalUpdateDueDateAndNotified
	api.GetExpensesForPeriod = originalGetExpensesForPeriod
	utils.CalculateNextDueDate = originalCalculateNextDueDate
	utils.GenerateExpenseSummaryMessage = originalGenerateExpenseSummaryMessage

	// Reset individual mock functions
	mockGetPendingUnnotifiedReminders = nil
	mockSendTextMessage = nil
	mockMarkReminderAsNotified = nil
	mockUpdateDueDateAndNotified = nil
	mockGetExpensesForPeriod = nil
	mockCalculateNextDueDate = nil
	mockGenerateExpenseSummaryMessage = nil
}

// --- Test Cases ---
func TestCheckDueReminders(t *testing.T) {
	os.Setenv("FB_PAGE_ACCESS_TOKEN", "test_token") // Set dummy token for tests

	// Get today's date at 00:00:00 for consistent due date comparisons
	now := time.Now()
	today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())

	testCases := []struct {
		name                         string
		setup                        func() // To set up specific mock behaviors for this test case
		expectedMarkAsNotifiedCalls  int
		expectedUpdateCalls          int
		expectedSendTextMessageCalls int
		// Add more assertions as needed: specific args for calls, errors, etc.
	}{
		{
			name: "Payment Reminder (once), due today, notification sent, marked as notified",
			setup: func() {
				mockGetPendingUnnotifiedReminders = func() ([]models.RemindersLog, error) {
					return []models.RemindersLog{
						{Model: models.Model{ID: 1}, UserID: "user1", DueDate: today, ReminderType: "payment", Frequency: "once", Amount: 100, Recipient: "Merchant"},
					}, nil
				}
				mockSendTextMessage = func(message, psid, token string) error {
					// assert.Contains(t, message, "payment of ₱100.00")
					// assert.Equal(t, "user1", psid)
					return nil
				}
				mockMarkReminderAsNotified = func(reminderID string) error {
					// assert.Equal(t, "1", reminderID)
					return nil
				}
			},
			expectedMarkAsNotifiedCalls: 1,
			expectedSendTextMessageCalls: 1,
			expectedUpdateCalls: 0,
		},
		{
			name: "Payment Reminder (weekly), due today, notification sent, rescheduled",
			setup: func() {
				mockGetPendingUnnotifiedReminders = func() ([]models.RemindersLog, error) {
					return []models.RemindersLog{
						{Model: models.Model{ID: 2}, UserID: "user2", DueDate: today, ReminderType: "payment", Frequency: "weekly", Amount: 50, Recipient: "Service"},
					}, nil
				}
				mockSendTextMessage = func(message, psid, token string) error { return nil }
				mockCalculateNextDueDate = func(currentDueDate time.Time, frequency string) (time.Time, error) {
					// assert.Equal(t, "weekly", frequency)
					return currentDueDate.AddDate(0,0,7), nil
				}
				mockUpdateDueDateAndNotified = func(reminderID string, newDueDate time.Time, notified bool) error {
					// assert.Equal(t, "2", reminderID)
					// assert.False(t, notified)
					// assert.True(t, newDueDate.Equal(today.AddDate(0,0,7)))
					return nil
				}
			},
			expectedMarkAsNotifiedCalls: 0,
			expectedSendTextMessageCalls: 1,
			expectedUpdateCalls: 1,
		},
		{
			name: "Expense Summary Reminder (daily), due today, expenses fetched, summary sent, rescheduled",
			setup: func() {
				mockGetPendingUnnotifiedReminders = func() ([]models.RemindersLog, error) {
					return []models.RemindersLog{
						{Model: models.Model{ID: 3}, UserID: "user3", DueDate: today, ReminderType: "expense_summary", Frequency: "daily"},
					}, nil
				}
				mockGetExpensesForPeriod = func(userID string, start time.Time, end time.Time) ([]models.ExpensesLog, float64, error) {
					// assert.Equal(t, "user3", userID)
					return []models.ExpensesLog{{Amount: 120}}, 120.0, nil
				}
				mockGenerateExpenseSummaryMessage = func(frequency string, expenses []models.ExpensesLog, totalAmount float64) string {
					// assert.Equal(t, "daily", frequency)
					// assert.Equal(t, 120.0, totalAmount)
					return "Your daily summary: ₱120.00"
				}
				mockSendTextMessage = func(message, psid, token string) error { return nil }
				mockCalculateNextDueDate = func(currentDueDate time.Time, frequency string) (time.Time, error) {
					return currentDueDate.AddDate(0,0,1), nil
				}
				mockUpdateDueDateAndNotified = func(reminderID string, newDueDate time.Time, notified bool) error { return nil }
			},
			expectedSendTextMessageCalls: 1,
			expectedUpdateCalls: 1,
		},
		{
			name: "Reminder not yet due",
			setup: func() {
				mockGetPendingUnnotifiedReminders = func() ([]models.RemindersLog, error) {
					return []models.RemindersLog{
						{Model: models.Model{ID: 4}, UserID: "user4", DueDate: today.AddDate(0,0,1), ReminderType: "payment", Frequency: "once"},
					}, nil
				}
			},
			expectedSendTextMessageCalls: 0,
			expectedMarkAsNotifiedCalls: 0,
			expectedUpdateCalls: 0,
		},
		{
			name: "SendTextMessage fails, should not update status",
			setup: func() {
				mockGetPendingUnnotifiedReminders = func() ([]models.RemindersLog, error) {
					return []models.RemindersLog{
						{Model: models.Model{ID: 5}, UserID: "user5", DueDate: today, ReminderType: "payment", Frequency: "once"},
					}, nil
				}
				mockSendTextMessage = func(message, psid, token string) error {
					return fmt.Errorf("failed to send")
				}
				// MarkAsNotified and Update should not be called if SendTextMessage fails and processingError is handled
			},
			expectedSendTextMessageCalls: 1, // Attempt to send
			expectedMarkAsNotifiedCalls: 0,  // Should not be called
			expectedUpdateCalls: 0,          // Should not be called
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			setupMocks() // Apply general mock setup
			tc.setup()   // Apply test-case specific mock behaviors

			// Counters for mock calls (a more robust way would be using testify/mock's .Called() features)
			var markAsNotifiedCalls, updateCalls, sendTextMessageCalls int

			// Override mocks to increment counters
			originalMarkReminderAsNotifiedCopy := api.MarkReminderAsNotified
			api.MarkReminderAsNotified = func(reminderID string) error {
				markAsNotifiedCalls++
				if mockMarkReminderAsNotified != nil { return mockMarkReminderAsNotified(reminderID) }
				return nil
			}
			originalUpdateDueDateAndNotifiedCopy := api.UpdateReminderDueDateAndNotifiedStatus
			api.UpdateReminderDueDateAndNotifiedStatus = func(reminderID string, newDueDate time.Time, notified bool) error {
				updateCalls++
				if mockUpdateDueDateAndNotified != nil { return mockUpdateDueDateAndNotified(reminderID, newDueDate, notified) }
				return nil
			}
			originalSendTextMessageCopy := utils.SendTextMessage
			utils.SendTextMessage = func(message, psid, token string) error {
				sendTextMessageCalls++
				if mockSendTextMessage != nil { return mockSendTextMessage(message, psid, token) }
				return nil
			}

			CheckDueReminders()

			if markAsNotifiedCalls != tc.expectedMarkAsNotifiedCalls {
				t.Errorf("Expected MarkReminderAsNotified to be called %d times, got %d", tc.expectedMarkAsNotifiedCalls, markAsNotifiedCalls)
			}
			if updateCalls != tc.expectedUpdateCalls {
				t.Errorf("Expected UpdateReminderDueDateAndNotifiedStatus to be called %d times, got %d", tc.expectedUpdateCalls, updateCalls)
			}
			if sendTextMessageCalls != tc.expectedSendTextMessageCalls {
				t.Errorf("Expected SendTextMessage to be called %d times, got %d", tc.expectedSendTextMessageCalls, sendTextMessageCalls)
			}

			// Restore overridden mocks for next test
			api.MarkReminderAsNotified = originalMarkReminderAsNotifiedCopy
			api.UpdateReminderDueDateAndNotifiedStatus = originalUpdateDueDateAndNotifiedCopy
			utils.SendTextMessage = originalSendTextMessageCopy

			teardownMocks() // Clean up mocks
		})
	}
}
